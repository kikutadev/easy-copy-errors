The following text is a code file. The structure of the text are sections that begin with ----, followed by a single line containing the file path and file name, followed by a variable amount of lines containing the file contents. The text representing the file ends when the symbols --END-- are encountered.
----
src/extension.ts
// src/extension.ts
import * as vscode from 'vscode';
import {
  copyAllDiagnosticsHandler,
  copyErrorsOnlyHandler,
  copyGroupedDiagnosticsHandler,
  copyGroupedErrorsOnlyHandler,
} from './commands/errorCommands';
import { copyVitestResultsHandler } from './commands/terminalCommands';
import {
  copyAllVitestResultsHandler,
  copySelectedVitestResultsHandler,
} from './commands/vitestCommands';

export function activate(context: vscode.ExtensionContext) {
  console.log('Extension "easy-copy-errors" is now active');

  // Register commands
  const allDiagnosticsCommand = vscode.commands.registerCommand(
    'easy-copy-errors.copyErrors',
    copyAllDiagnosticsHandler
  );

  const errorsOnlyCommand = vscode.commands.registerCommand(
    'easy-copy-errors.copyErrorsOnly',
    copyErrorsOnlyHandler
  );

  const groupedDiagnosticsCommand = vscode.commands.registerCommand(
    'easy-copy-errors.copyGroupedErrors',
    copyGroupedDiagnosticsHandler
  );

  const groupedErrorsOnlyCommand = vscode.commands.registerCommand(
    'easy-copy-errors.copyGroupedErrorsOnly',
    copyGroupedErrorsOnlyHandler
  );

  // 旧コマンド（互換性のために維持）
  const vitestResultsCommand = vscode.commands.registerCommand(
    'easy-copy-errors.copyVitestResults',
    copyVitestResultsHandler
  );

  // 新コマンド：ファイル単位で選択してコピー
  const selectVitestResultsCommand = vscode.commands.registerCommand(
    'easy-copy-errors.selectVitestResults',
    copySelectedVitestResultsHandler
  );

  // 新コマンド：すべての失敗テストをコピー（選択UIなし）
  const allVitestResultsCommand = vscode.commands.registerCommand(
    'easy-copy-errors.copyAllVitestResults',
    copyAllVitestResultsHandler
  );

  context.subscriptions.push(
    allDiagnosticsCommand,
    errorsOnlyCommand,
    groupedDiagnosticsCommand,
    groupedErrorsOnlyCommand,
    vitestResultsCommand,
    selectVitestResultsCommand,
    allVitestResultsCommand
  );
}

export function deactivate() {}

----
src/test/extension.test.ts
import * as assert from 'assert';

// You can import and use all API from the 'vscode' module
// as well as import your extension to test it
import * as vscode from 'vscode';
// import * as myExtension from '../../extension';

suite('Extension Test Suite', () => {
	vscode.window.showInformationMessage('Start all tests.');

	test('Sample test', () => {
		assert.strictEqual(-1, [1, 2, 3].indexOf(5));
		assert.strictEqual(-1, [1, 2, 3].indexOf(0));
	});
});

----
src/utils/regexPatterns.ts
// src/utils/regexPatterns.ts

/**
 * Vitestのテスト結果パースに使用する正規表現パターン
 * パターンの管理を一元化して保守性を向上させる
 */
export const VitestPatterns = {
  /**
   * FAIL行パターン
   * 例: FAIL src/example.test.ts
   */
  failLine: /\s*FAIL\s+/g,

  /**
   * テスト名抽出パターン
   * 例: NavigationHandler > handleBeforeUnload > ビーコンを正しく送信する
   */
  testName: /^([^\n]+)/,

  /**
   * ファイルパス抽出パターン
   * 例: src/recorder/recorder/handlers/NavigationHandler.test.ts
   */
  filePath: /([a-zA-Z0-9_\-/.]+\.(spec|test)\.[jt]sx?)/i,

  /**
   * エラーメッセージ抽出パターン
   * 例: AssertionError: expected "spy" to be called with arguments: [ { type: 'HISTORY_NAVIGATE', …(4) } ]
   */
  errorMessage:
    /(?:AssertionError|TypeError|Error):\s+(.+?)(?=\n\s*❯|\n\s*\n|\n\s*$)/s,

  /**
   * 行番号情報抽出パターン
   * 例: ❯ src/recorder/recorder/handlers/NavigationHandler.test.ts:162:42
   */
  lineNumber: /❯\s+[\w/\.\-]+:(\d+:\d+)/,

  /**
   * コードスニペット抽出パターン群
   */
  codeSnippet: [
    // Vitestの行番号つきコードスニペット (❯ から始まる行を含む最小限のブロック)
    /❯\s+[\w/\.\-]+:\d+:\d+[\s\S]*?(?=\n\s*⎯{10,}|\n\s*FAIL|\n\s*$|$)/s,

    // 行番号とパイプ記号を含むコードスニペット（より多くの行を含むようにパターンを改善）
    /\n\s*\d+\s*\|\s*.+\n\s*\d+\s*\|\s*.+\n\s*\d+\s*\|\s*.+(?:\n\s*\d+\s*\|\s*.+)*/s,

    // カラット(^)を含むコード行
    /\n\s*\d+\s*\|.*\n\s*\|.*\^.*\n/s,

    // 以前のパターンをフォールバックとして保持
    /(\[\n|\s+\[\n)[\s\S]*?(\]\n|\s+\]\n)/s,
    /\n\s*at\s+[^\n]+\n\s*at\s+[^\n]+/s,
    /\{\s*[\s\S]*?:\s*["'][\s\S]*?["'][\s\S]*?\}/s,
  ],

  /**
   * 期待値抽出パターン群
   */
  expected: [
    /Expected:[\s\S]*?(?=\n\s*Received:|\n\s*Number of calls:|\n\s*$)/,
    /Expected value:[\s\S]*?(?=\n\s*Received:|\n\s*Actual:|\n\s*$)/,
    /expect\([^)]+\)\.to[A-Za-z]+\(([^)]+)\)/,
    /Expected [\s\S]*?(?=\n\s*but got:|\n\s*$)/i,
  ],

  /**
   * 実際値抽出パターン群
   */
  received: [
    // Receivedとその後のNumber of callsまでを一括で抽出するように改善
    /Received:[\s\S]*?(?:Number of calls:[^\n]*(?:\n\s*\n|\n\s*❯|\n\s*⎯{10,}|\n\s*$|$))/s,
    /Actual:[\s\S]*?(?=\n\s*$|$)/,
    /But got:[\s\S]*?(?=\n\s*$|$)/,
    /Instead received:[\s\S]*?(?=\n\s*$|$)/,
  ],

  /**
   * テストファイルパスとテスト名の組み合わせパターン
   * 例: FAIL src/recorder/recorder/ActionRecorder.test.ts > ActionRecorder > 基本機能
   */
  filePathWithTestName:
    /FAIL\s+([a-zA-Z0-9_\-/.]+\.(spec|test)\.[jt]sx?)\s+>\s+([^>][^\n]+?)(?=\s+\d+ms|\s*$)/,

  /**
   * 失敗したテスト検出パターン群
   */
  failedTestPatterns: [
    // パターン1: 「×」マークでテスト名とメッセージが含まれるもの
    /(?:×|✗|✘)\s+([^\n]+?)\s+\d+ms\s*\n[^\n]*?→\s+([^\n]+)/g,

    // パターン2: 「FAIL」や「ERROR」などが含まれるもの
    /(?:FAIL|ERROR|FAILED)(?:\s*-\s*|\s+)([^\n]+)\s*\n[^\n]*?(?:Error|Failed|AssertionError):\s*([^\n]+)/g,

    // パターン3: テスト名が引用符で囲まれたスタイル
    /test\s+['"]([^'"]+)['"]\s+(?:failed|did not pass)(?:[^\n]*)(?:\n[^\n]*?(?:Error|Failed):\s*([^\n]+))?/g,

    // パターン4: FaIL行とAssertionErrorを含むVitest出力形式
    /FAIL\s+(.+?)(?=\n\s*)(?:\n\s*)((?:AssertionError|Error):[^\n]+)/g,
  ],

  /**
   * ファイルパス検出パターン群
   */
  filePathPatterns: [
    /(?:FAIL|ERROR|FAILED)\s+([^\s]+\.[jt]sx?)/i,
    /● ([^\s]+\.[jt]sx?)/i,
    /([^/\s]+\/[^\s]+\.[jt]sx?)/i,
    /([a-zA-Z0-9_\-/.]+\.(spec|test)\.[jt]sx?)/i,
  ],

  /**
   * テスト名とファイルパスの抽出パターン
   * 例: FAIL src/recorder/recorder/handlers/NavigationHandler.test.ts > ActionRecorder > 基本機能
   */
  filePathAndTestName:
    /FAIL\s+([a-zA-Z0-9_\-/.]+\.(spec|test)\.[jt]sx?)\s+>\s+(.+?)(?=\n)/i,

  /**
   * エラーや失敗を示す行の抽出パターン
   * 例: error: expected value to match
   */
  errorLine: /(?:error|fail|failed|assertion)(?:\s*:\s*|\s+)(.+)/i,

  /**
   * テスト関数の名前抽出パターン
   * 例: test("should do something")
   */
  testFunction: /(?:test|it|describe)(?:\s*\(\s*|\s+)['"]([^'"]+)['"]/i,

  /**
   * 行番号とコロンを含むパターン
   * 例: 10:42
   */
  lineNumberInText: /[:\s](\d+:\d+)[\s:]/,

  /**
   * 詳細なエラーセクションの区切りパターン
   */
  errorSectionDivider: /⎯{10,}[^\n]*\n\n/,

  /**
   * Failed Testsセクションのパターン
   */
  failedTestsHeader: /Failed Tests \d+/,
};

----
src/utils/file.ts
// src/utils/file.ts
import * as vscode from 'vscode';
import * as path from 'path';

/**
 * 指定されたURIから、ワークスペースルートからの相対パスを取得
 */
export function getRelativePath(uri: vscode.Uri): string {
  const workspaceFolder = vscode.workspace.getWorkspaceFolder(uri);
  if (workspaceFolder) {
    return path.relative(workspaceFolder.uri.fsPath, uri.fsPath);
  }
  return uri.fsPath;
}

/**
 * 指定されたURIからファイル名のみを取得
 */
export function getFileName(uri: vscode.Uri): string {
  return path.basename(uri.fsPath);
}

----
src/utils/config.ts
// src/utils/config.ts
import * as vscode from 'vscode';

/**
 * 拡張機能の設定を取得
 */
export function getConfiguration() {
  return vscode.workspace.getConfiguration('easyCopyErrors');
}

/**
 * 新しいフォーマットを使用するかどうかを取得
 */
export function useNewFormat(): boolean {
  return getConfiguration().get<boolean>('useNewFormat') ?? true;
}

/**
 * カスタムフォーマット文字列を取得
 */
export function getCustomFormat(): string {
  return (
    getConfiguration().get<string>('format') ||
    '[${severity}] Line ${line}, Column ${column}: ${message}'
  );
}

/**
 * ファイル名を含めるかどうかを取得
 */
export function includeFileName(): boolean {
  return getConfiguration().get<boolean>('includeFileName') ?? true;
}

/**
 * エラーをグループ化するかどうかを取得
 */
export function useGrouping(): boolean {
  return getConfiguration().get<boolean>('useGrouping') ?? false;
}

----
src/commands/terminalCommands.ts
// src/commands/terminalCommands.ts
import { copySelectedVitestResultsHandler } from './vitestCommands';

/**
 * Vitestテスト結果をコピーするコマンドハンドラー
 * 互換性のために維持。実際の処理は vitestCommands.ts に移動
 */
export async function copyVitestResultsHandler(): Promise<void> {
  // 選択UIを使う新しい実装にリダイレクト
  await copySelectedVitestResultsHandler();
}

----
src/commands/vitestCommands.ts
// src/commands/vitestCommands.ts
import * as vscode from 'vscode';
import { copyToClipboard } from '../services/clipboardService';
import { captureTerminalText } from '../services/terminalCaptureService';
import {
  showIndividualTestSelectionUI,
  showTestFileSelectionUI,
} from '../services/testSelectionService';
import {
  formatFailedTests,
  groupTestsByFile,
  parseVitestOutput,
} from '../services/vitestParserService';

/**
 * Vitestテスト結果をファイル単位で選択してコピーするコマンドハンドラー
 */
export async function copySelectedVitestResultsHandler(): Promise<void> {
  vscode.window.showInformationMessage(
    'Vitestテスト結果をキャプチャしています...'
  );

  // ターミナルテキストをキャプチャ
  const terminalText = await captureTerminalText();

  if (!terminalText) {
    vscode.window.showErrorMessage(
      'ターミナルテキストのキャプチャに失敗しました'
    );
    return;
  }

  // テスト結果を解析
  const failedTests = parseVitestOutput(terminalText);

  if (failedTests.length === 0) {
    vscode.window.showInformationMessage(
      '失敗したテストが見つかりませんでした'
    );
    return;
  }

  // ファイル別にグループ化
  const testGroups = groupTestsByFile(failedTests);

  // テストファイル選択UIを表示
  const selectedFileGroup = await showTestFileSelectionUI(testGroups);
  if (!selectedFileGroup) {
    // キャンセルされた
    return;
  }

  // 個別テスト選択UIを表示
  const selectedTests = await showIndividualTestSelectionUI(selectedFileGroup);
  if (!selectedTests) {
    // キャンセルされた
    return;
  }

  // 選択されたテストをフォーマットしてコピー
  const formattedText = formatFailedTests(selectedTests);
  const success = await copyToClipboard(formattedText);

  if (success) {
    vscode.window.showInformationMessage(
      `${selectedTests.length}件の失敗したテストをコピーしました`
    );
  } else {
    vscode.window.showErrorMessage('テスト結果のコピーに失敗しました');
  }
}

/**
 * シンプルな全テスト結果コピーハンドラー（以前の実装と同じ）
 */
export async function copyAllVitestResultsHandler(): Promise<void> {
  vscode.window.showInformationMessage(
    'Vitestテスト結果をキャプチャしています...'
  );

  const terminalText = await captureTerminalText();

  if (!terminalText) {
    vscode.window.showErrorMessage(
      'ターミナルテキストのキャプチャに失敗しました'
    );
    return;
  }

  const failedTests = parseVitestOutput(terminalText);

  if (failedTests.length === 0) {
    vscode.window.showInformationMessage(
      '失敗したテストが見つかりませんでした'
    );
    return;
  }

  const formattedText = formatFailedTests(failedTests);
  const success = await copyToClipboard(formattedText);

  if (success) {
    vscode.window.showInformationMessage(
      `${failedTests.length}件の失敗したテストをコピーしました`
    );
  } else {
    vscode.window.showErrorMessage('テスト結果のコピーに失敗しました');
  }
}

----
src/commands/errorCommands.ts
// src/commands/errorCommands.ts
import * as vscode from 'vscode';
import {
  getCurrentFileDiagnostics,
  filterDiagnostics,
  buildDiagnosticContext,
  groupDiagnostics,
} from '../services/diagnosticsService';
import {
  formatDiagnostics,
  formatDiagnosticGroups,
} from '../services/formatterService';
import {
  copyToClipboard,
  showCopySuccessMessage,
  showNoDiagnosticsMessage,
  showNoEditorMessage,
} from '../services/clipboardService';
import { useGrouping } from '../utils/config';

/**
 * すべての診断情報をコピーするコマンドハンドラー
 */
export async function copyAllDiagnosticsHandler(): Promise<void> {
  await copyDiagnosticsWithOptions({ errorsOnly: false });
}

/**
 * エラーのみをコピーするコマンドハンドラー
 */
export async function copyErrorsOnlyHandler(): Promise<void> {
  await copyDiagnosticsWithOptions({ errorsOnly: true });
}

/**
 * グループ化したすべての診断情報をコピーするコマンドハンドラー
 */
export async function copyGroupedDiagnosticsHandler(): Promise<void> {
  await copyDiagnosticsWithOptions({ errorsOnly: false, forceGrouped: true });
}

/**
 * グループ化したエラーのみをコピーするコマンドハンドラー
 */
export async function copyGroupedErrorsOnlyHandler(): Promise<void> {
  await copyDiagnosticsWithOptions({ errorsOnly: true, forceGrouped: true });
}

/**
 * オプションを指定して診断情報をコピー
 */
async function copyDiagnosticsWithOptions(options: {
  errorsOnly: boolean;
  forceGrouped?: boolean;
}): Promise<void> {
  // 設定からグループ化の設定を取得（または強制的にグループ化）
  const grouped = options.forceGrouped || useGrouping();

  // 現在のファイルの診断情報を取得
  const diagnostics = getCurrentFileDiagnostics();

  if (!diagnostics) {
    showNoEditorMessage();
    return;
  }

  // 診断情報をフィルタリング
  const filteredDiagnostics = filterDiagnostics(diagnostics, options);

  if (filteredDiagnostics.length === 0) {
    showNoDiagnosticsMessage(options.errorsOnly);
    return;
  }

  const editor = vscode.window.activeTextEditor!;
  let formattedText: string;

  // グループ化するかどうかで処理を分岐
  if (grouped) {
    // 診断情報をグループ化
    const groups = groupDiagnostics(filteredDiagnostics, editor.document);
    formattedText = formatDiagnosticGroups(groups);
  } else {
    // 通常のフォーマット
    formattedText = formatDiagnostics(
      filteredDiagnostics,
      editor.document,
      buildDiagnosticContext
    );
  }

  // クリップボードにコピー
  const success = await copyToClipboard(formattedText);

  if (success) {
    showCopySuccessMessage(options.errorsOnly, grouped);
  }
}

----
src/services/formatterService.ts
// src/services/formatterService.ts
import * as vscode from 'vscode';
import { getFileName, getRelativePath } from '../utils/file';
import {
  useNewFormat,
  getCustomFormat,
  includeFileName,
} from '../utils/config';
import { DiagnosticContext, DiagnosticGroup } from './diagnosticsService';

/**
 * 診断情報をフォーマット
 */
export function formatDiagnostic(context: DiagnosticContext): string {
  if (useNewFormat()) {
    return formatNewStyle(context);
  } else {
    return formatCustomStyle(context);
  }
}

/**
 * 新しいスタイルでフォーマット（AIプロンプト向け）
 */
function formatNewStyle(context: DiagnosticContext): string {
  const { document, line, lineContent, message } = context;
  const relativePath = getRelativePath(document.uri);

  return `file: ${relativePath}\nLine ${line}:      ${lineContent}\n${message}`;
}

/**
 * カスタムスタイルでフォーマット（ユーザー設定に基づく）
 */
function formatCustomStyle(context: DiagnosticContext): string {
  const { document, line, column, lineContent, severity, message } = context;
  const fileName = getFileName(document.uri);
  const relativePath = getRelativePath(document.uri);

  let format = getCustomFormat();

  let formatted = format
    .replace(/\${severity}/g, severity)
    .replace(/\${line}/g, line.toString())
    .replace(/\${column}/g, column.toString())
    .replace(/\${message}/g, message)
    .replace(/\${lineContent}/g, lineContent);

  if (includeFileName()) {
    formatted = formatted
      .replace(/\${file}/g, fileName)
      .replace(/\${relativePath}/g, relativePath);
  }

  return formatted;
}

/**
 * 複数の診断情報をフォーマットして結合
 */
export function formatDiagnostics(
  diagnostics: vscode.Diagnostic[],
  document: vscode.TextDocument,
  buildContext: (
    diag: vscode.Diagnostic,
    doc: vscode.TextDocument
  ) => DiagnosticContext
): string {
  return diagnostics
    .map((diag) => formatDiagnostic(buildContext(diag, document)))
    .join('\n\n');
}

/**
 * グループ化された診断情報をフォーマット
 */
export function formatDiagnosticGroups(groups: DiagnosticGroup[]): string {
  return groups
    .map((group) => formatDiagnosticGroup(group))
    .join('\n\n---\n\n');
}

/**
 * 単一の診断情報グループをフォーマット（シンプルなスタイル）
 * 同じファイル内で同じエラーメッセージのものをまとめる
 */
function formatDiagnosticGroup(group: DiagnosticGroup): string {
  const { contexts, message } = group;

  if (contexts.length === 0) {
    return '';
  }

  // 最初のコンテキストからファイル情報を取得
  const firstContext = contexts[0];
  const relativePath = getRelativePath(firstContext.document.uri);

  // ファイル情報を出力
  let result = `file: ${relativePath}\n`;

  // 各行の情報をフォーマット
  contexts.forEach((context) => {
    result += `Line ${context.line}: ${context.lineContent}\n`;
  });

  // エラーメッセージを最後に追加
  result += `${message}`;

  return result;
}

----
src/services/testSelectionService.ts
// src/services/testSelectionService.ts
import * as vscode from 'vscode';
import { TestFileGroup, FailedTest } from './vitestParserService';

/**
 * テストファイル選択用のQuickPickアイテム
 */
interface TestFileQuickPickItem extends vscode.QuickPickItem {
  fileGroup: TestFileGroup;
}

/**
 * 個別テスト選択用のQuickPickアイテム
 */
interface TestQuickPickItem extends vscode.QuickPickItem {
  test: FailedTest;
}

/**
 * テストファイル選択UIを表示
 * テスト結果をファイル単位でグループ化し、選択UIを提供する
 * @param testGroups ファイル別にグループ化されたテスト結果
 * @returns 選択されたテストファイルグループ、またはキャンセルされた場合はundefined
 */
export async function showTestFileSelectionUI(
  testGroups: TestFileGroup[]
): Promise<TestFileGroup | undefined> {
  // ファイル数が1つの場合は直接返す（UIをスキップ）
  if (testGroups.length === 1) {
    return testGroups[0];
  }

  // QuickPickアイテムに変換
  const items: TestFileQuickPickItem[] = testGroups.map((group) => ({
    label: group.displayName,
    description: `失敗テスト: ${group.failedTests.length}件`,
    detail: group.filePath,
    fileGroup: group,
  }));

  // QuickPickを表示
  const selectedItem = await vscode.window.showQuickPick(items, {
    placeHolder: 'コピーするテストファイルを選択してください',
    matchOnDescription: true,
    matchOnDetail: true,
  });

  return selectedItem?.fileGroup;
}

/**
 * 個別テスト選択UIを表示
 * 指定されたファイルグループ内のテストを選択するUIを提供する
 * 複数選択可能で、「全てのテストを選択」オプションも提供
 * @param fileGroup テストファイルグループ
 * @returns 選択されたテスト配列、またはキャンセルされた場合はundefined
 */
export async function showIndividualTestSelectionUI(
  fileGroup: TestFileGroup
): Promise<FailedTest[] | undefined> {
  // テスト数が1つの場合は直接返す（UIをスキップ）
  if (fileGroup.failedTests.length === 1) {
    return fileGroup.failedTests;
  }

  // 「全てのテストを選択」オプションを追加
  const allTestsOption: vscode.QuickPickItem = {
    label: '$(check-all) 全てのテストを選択',
    description: `(${fileGroup.failedTests.length}件)`,
    kind: vscode.QuickPickItemKind.Separator,
  };

  // 個別のテストアイテム
  const testItems: TestQuickPickItem[] = fileGroup.failedTests.map((test) => ({
    label: test.testName,
    description: test.lineNumber ? `行: ${test.lineNumber}` : '',
    detail: test.errorMessage,
    test: test,
  }));

  // マルチ選択QuickPickを表示
  const selectedItems = (await vscode.window.showQuickPick(
    [allTestsOption, ...testItems],
    {
      placeHolder: 'コピーするテストを選択してください（複数選択可）',
      canPickMany: true,
      matchOnDescription: true,
      matchOnDetail: true,
    }
  )) as TestQuickPickItem[];

  // 選択されたアイテムがない場合
  if (!selectedItems || selectedItems.length === 0) {
    return undefined;
  }

  // 「全てのテストを選択」が選ばれていれば全テストを返す
  if (selectedItems.some((item) => item.label === allTestsOption.label)) {
    return fileGroup.failedTests;
  }

  // 選択されたテストを返す
  return selectedItems.map((item) => item.test);
}

----
src/services/vitestParserService.ts
// src/services/vitestParserService.ts
import {
  extractTestsMethod1,
  extractTestsMethod2,
  extractTestsMethod3,
} from './vitestExtractorService';

/**
 * 失敗したVitestテストの情報
 */
export interface FailedTest {
  filePath: string; // テストファイルのパス
  testName: string; // テスト名
  errorMessage: string; // エラーメッセージ
  codeSnippet: string; // エラー箇所のコードスニペット
  lineNumber: string; // エラー発生行番号
  expected: string; // 期待値
  received: string; // 実際値
}

/**
 * ファイル別にグループ化された失敗テスト
 */
export interface TestFileGroup {
  filePath: string; // ファイルパス
  displayName: string; // 表示用ファイル名
  failedTests: FailedTest[]; // このファイル内の失敗テスト一覧
}

/**
 * Vitestのテスト出力から失敗したテストを抽出する
 * 複数の抽出方法を試し、結果が見つからない場合は次の方法を試すフォールバック機構を実装
 * @param text ターミナルからキャプチャしたテキスト
 * @returns 抽出された失敗テスト情報の配列
 */
export function parseVitestOutput(text: string): FailedTest[] {
  // まず最初の抽出方法を試す
  let failedTests = extractTestsMethod1(text);

  // 失敗したテストが見つからなかった場合、別の抽出方法を試す
  if (failedTests.length === 0) {
    console.log(
      '抽出方法1で失敗したテストが見つかりませんでした。方法2を試します。'
    );
    failedTests = extractTestsMethod2(text);
  }

  // それでも見つからない場合、最後の抽出方法を試す
  if (failedTests.length === 0) {
    console.log(
      '抽出方法2で失敗したテストが見つかりませんでした。方法3を試します。'
    );
    failedTests = extractTestsMethod3(text);
  }

  // 結果の後処理：重複の除去と整理
  const uniqueTests = removeDuplicateTests(failedTests);

  // デバッグ情報
  console.log(`抽出されたテスト数: ${uniqueTests.length}`);
  uniqueTests.forEach((test) => {
    console.log(`ファイル: ${test.filePath}, テスト: ${test.testName}`);
  });

  return uniqueTests;
}

/**
 * 抽出されたテストから重複を除去する
 * ファイルパスとテスト名の組み合わせが同じものを重複と見なす
 */
function removeDuplicateTests(tests: FailedTest[]): FailedTest[] {
  const uniqueTests: FailedTest[] = [];
  const keys = new Set<string>();

  for (const test of tests) {
    const key = `${test.filePath}::${test.testName}`;
    if (!keys.has(key)) {
      keys.add(key);
      uniqueTests.push(test);
    }
  }

  return uniqueTests;
}
/**
 * 失敗したテストをファイル別にグループ化する
 * 同じファイルパスのテストをまとめ、ファイル名でソートする
 * @param tests 失敗テスト情報の配列
 * @returns ファイル別にグループ化されたテスト情報
 */
export function groupTestsByFile(tests: FailedTest[]): TestFileGroup[] {
  // ファイルパスごとにグループ化
  const groups: { [key: string]: TestFileGroup } = {};

  tests.forEach((test) => {
    if (!groups[test.filePath]) {
      // ファイル名の部分だけを抽出（表示用）
      const displayName = test.filePath.split('/').pop() || test.filePath;

      groups[test.filePath] = {
        filePath: test.filePath,
        displayName,
        failedTests: [],
      };
    }

    groups[test.filePath].failedTests.push(test);
  });

  // 配列に変換してファイルパスでソート
  return Object.values(groups).sort((a, b) =>
    a.filePath.localeCompare(b.filePath)
  );
}

/**
 * 失敗したテスト情報を読みやすい形式にフォーマットする
 * @param failedTests フォーマットする失敗テスト情報の配列
 * @returns フォーマットされたテキスト
 */
export function formatFailedTests(failedTests: FailedTest[]): string {
  return failedTests
    .map((test) => {
      let result = `file: ${test.filePath}`;

      // expectedとreceivedが存在する場合は先に表示
      if (test.expected) {
        result += `\n\nexpected:\n${test.expected}`;
      }

      if (test.received) {
        result += `\n\nreceived:\n${test.received}`;
      }

      // コードスニペットを最後に表示
      if (test.codeSnippet) {
        result += `\n\ncode snippet:\n${test.codeSnippet}`;
      }

      return result;
    })
    .join('\n\n---\n\n');
}

----
src/services/vitestExtractorService.ts
// src/services/vitestExtractorService.ts
import { VitestPatterns } from '../utils/regexPatterns';
import { FailedTest } from './vitestParserService';

/**
 * Vitestのテスト結果から期待値を抽出する
 * 複数の正規表現パターンを試し、最初にマッチしたものを返す
 * @param text 抽出対象のテキスト
 * @returns 抽出された期待値の文字列、見つからない場合は空文字列
 */
export function extractExpected(text: string): string {
  for (const pattern of VitestPatterns.expected) {
    const match = pattern.exec(text);
    if (match) {
      return match[0].trim();
    }
  }
  return '';
}

/**
 * Vitestのテスト結果から実際値を抽出する
 * 複数の正規表現パターンを試し、最初にマッチしたものを返す
 * @param text 抽出対象のテキスト
 * @returns 抽出された実際値の文字列、見つからない場合は空文字列
 */
export function extractReceived(text: string): string {
  for (const pattern of VitestPatterns.received) {
    const match = pattern.exec(text);
    if (match) {
      return match[0].trim();
    }
  }
  return '';
}

/**
 * Vitestのテスト結果からコードスニペットを抽出する
 * 複数の正規表現パターンを試し、最初にマッチしたものを返す
 * @param text 抽出対象のテキスト
 * @returns 抽出されたコードスニペットの文字列、見つからない場合は空文字列
 */
export function extractCodeSnippet(text: string): string {
  // テキスト中に行番号付きのコードスニペットが含まれているかチェック
  const snippetIndex = text.indexOf('❯ ');
  if (snippetIndex !== -1) {
    // ❯ 行を含む周辺のテキストを抽出
    const snippetContext = text.substring(snippetIndex);
    // コードスニペットパターンを適用
    for (const pattern of VitestPatterns.codeSnippet) {
      const snippetMatch = pattern.exec(snippetContext);
      if (snippetMatch) {
        return snippetMatch[0].trim();
      }
    }
  }

  // 通常のコードスニペット抽出
  for (const pattern of VitestPatterns.codeSnippet) {
    const match = pattern.exec(text);
    if (match) {
      return match[0].trim();
    }
  }
  return '';
}

/**
 * Vitestのテスト結果から失敗したテストを抽出する（方法1）
 * FAIL行を区切りとしてセクションに分割し、各セクションから情報を抽出する
 * @param text 解析対象のテキスト
 * @returns 抽出された失敗テスト情報の配列
 */
export function extractTestsMethod1(text: string): FailedTest[] {
  const failedTests: FailedTest[] = [];

  // ファイルパスとテスト名を一度に抽出するパターンを試す
  const fileTestMatches = Array.from(
    text.matchAll(VitestPatterns.filePathWithTestName)
  );

  if (fileTestMatches.length > 0) {
    // 各マッチに対して処理
    for (const match of fileTestMatches) {
      const filePath = match[1];
      const testName = match[3].trim();

      // テストセクションの開始位置を特定
      const matchPosition = match.index || 0;
      const testStart = text.indexOf('\n', matchPosition) + 1;

      // 次のテストセクションの開始位置を特定
      let testEnd = text.indexOf('\n FAIL ', testStart);
      if (testEnd === -1) {
        testEnd = text.indexOf('\n⎯⎯⎯⎯⎯⎯⎯⎯⎯', testStart);
      }
      if (testEnd === -1) {
        testEnd = text.length;
      }

      // テストセクションを抽出
      const testSection = text.substring(testStart, testEnd);

      // エラーメッセージを抽出
      const errorMatch = testSection.match(VitestPatterns.errorMessage);
      const errorMessage = errorMatch ? errorMatch[1].trim() : '';

      // 行番号情報を抽出
      const lineNumberMatch = testSection.match(VitestPatterns.lineNumber);
      const lineNumber = lineNumberMatch ? lineNumberMatch[1] : '';

      // コードスニペットを抽出
      const codeSnippet = extractCodeSnippet(testSection);

      // 期待値と実際の値を抽出
      const expected = extractExpected(testSection);
      const received = extractReceived(testSection);

      failedTests.push({
        filePath,
        testName,
        errorMessage,
        codeSnippet,
        lineNumber,
        expected,
        received,
      });
    }

    // マッチが見つかった場合は結果を返す
    if (failedTests.length > 0) {
      return failedTests;
    }
  }

  // テストファイルのセクションを検出
  const testSections = text.split(VitestPatterns.failLine);

  for (let i = 1; i < testSections.length; i++) {
    const section = testSections[i];

    // ファイルパスを抽出
    const filePathMatch = section.match(VitestPatterns.filePath);
    if (!filePathMatch) {
      continue;
    }

    const filePath = filePathMatch[1];

    // テスト名を抽出
    const testNameMatch = section.match(VitestPatterns.testName);
    if (!testNameMatch) {
      continue;
    }

    const testName = testNameMatch[1].trim();

    // エラーメッセージを抽出
    const errorMatch = section.match(VitestPatterns.errorMessage);
    const errorMessage = errorMatch ? errorMatch[1].trim() : '';

    // 行番号情報を抽出
    const lineNumberMatch = section.match(VitestPatterns.lineNumber);
    const lineNumber = lineNumberMatch ? lineNumberMatch[1] : '';

    // コードスニペットを抽出
    const codeSnippet = extractCodeSnippet(section);

    // 期待値と実際の値を抽出
    const expected = extractExpected(section);
    const received = extractReceived(section);

    failedTests.push({
      filePath,
      testName,
      errorMessage,
      codeSnippet,
      lineNumber,
      expected,
      received,
    });
  }

  return failedTests;
}

/**
 * Vitestのテスト結果から失敗したテストを抽出する（方法2）
 * 複数のパターンを使用して失敗テストを検出し、各テストの前後のコンテキストから情報を抽出する
 * @param text 解析対象のテキスト
 * @returns 抽出された失敗テスト情報の配列
 */
export function extractTestsMethod2(text: string): FailedTest[] {
  const failedTests: FailedTest[] = [];

  // 詳細なエラーセクションを抽出
  const errorSections = text.split(VitestPatterns.errorSectionDivider);
  for (const section of errorSections) {
    if (!section.includes('FAIL ')) {
      continue;
    }

    // ファイルパスとテスト名を抽出
    const headerMatch = section.match(VitestPatterns.filePathWithTestName);
    if (headerMatch) {
      const filePath = headerMatch[1];
      const testName = headerMatch[3].trim();

      // エラーメッセージを抽出
      const errorMatch = section.match(VitestPatterns.errorMessage);
      const errorMessage = errorMatch ? errorMatch[1].trim() : '';

      // 行番号情報を抽出
      const lineNumberMatch = section.match(VitestPatterns.lineNumber);
      const lineNumber = lineNumberMatch ? lineNumberMatch[1] : '';

      // コードスニペットを抽出
      const codeSnippet = extractCodeSnippet(section);

      // 期待値と実際の値を抽出
      const expected = extractExpected(section);
      const received = extractReceived(section);

      failedTests.push({
        filePath,
        testName,
        errorMessage,
        codeSnippet,
        lineNumber,
        expected,
        received,
      });
    }
  }

  // 結果が見つかった場合は返す
  if (failedTests.length > 0) {
    return failedTests;
  }

  // 失敗したテストの複数のパターンを試す
  for (const pattern of VitestPatterns.failedTestPatterns) {
    // 正規表現のグローバルインデックスをリセット
    pattern.lastIndex = 0;

    let match;
    while ((match = pattern.exec(text)) !== null) {
      const testName = match[1].trim();
      const errorMessage = (match[2] || 'Unknown error').trim();

      // テストの詳細テキストを抽出（エラー周辺の約1000文字）
      const contextStartIdx = Math.max(0, match.index - 200);
      const contextEndIdx = Math.min(
        text.length,
        match.index + match[0].length + 800
      );
      const detailText = text.substring(contextStartIdx, contextEndIdx);

      // ファイルパスを抽出
      let filePath = 'unknown-file';
      for (const filePattern of VitestPatterns.filePathPatterns) {
        const fileMatch = detailText.match(filePattern);
        if (fileMatch) {
          filePath = fileMatch[1];
          break;
        }
      }

      // 行番号情報を抽出
      const lineNumberMatch = detailText.match(VitestPatterns.lineNumber);
      const lineNumber = lineNumberMatch ? lineNumberMatch[1] : '';

      // 期待値と実際の値を抽出
      const expected = extractExpected(detailText);
      const received = extractReceived(detailText);
      const codeSnippet = extractCodeSnippet(detailText);

      failedTests.push({
        filePath,
        testName,
        errorMessage,
        codeSnippet,
        lineNumber,
        expected,
        received,
      });
    }
  }

  return failedTests;
}

/**
 * Vitestのテスト結果から失敗したテストを抽出する（方法3）
 * FAILセクションを検索するか、エラー関連の行を検索して情報を抽出する
 * 他の方法が失敗した場合のフォールバックとして使用
 * @param text 解析対象のテキスト
 * @returns 抽出された失敗テスト情報の配列
 */
export function extractTestsMethod3(text: string): FailedTest[] {
  const failedTests: FailedTest[] = [];

  // 詳細なエラー情報セクションを探す
  const detailedErrorSections = text.split(VitestPatterns.failedTestsHeader);
  if (detailedErrorSections.length > 1) {
    const detailedSection = detailedErrorSections[1];
    const individualTests = detailedSection.split(/\n\s*FAIL\s+/);

    for (let i = 1; i < individualTests.length; i++) {
      const testSection = 'FAIL ' + individualTests[i];

      // ファイルパスとテスト名を抽出
      const fileTestMatch = testSection.match(
        VitestPatterns.filePathAndTestName
      );
      if (fileTestMatch) {
        const filePath = fileTestMatch[1];
        const testName = fileTestMatch[3].trim();

        // エラーメッセージを抽出
        const errorMatch = testSection.match(VitestPatterns.errorMessage);
        const errorMessage = errorMatch ? errorMatch[1].trim() : '';

        // 行番号情報を抽出
        const lineNumberMatch = testSection.match(VitestPatterns.lineNumber);
        const lineNumber = lineNumberMatch ? lineNumberMatch[1] : '';

        // コードスニペットを抽出
        const codeSnippet = extractCodeSnippet(testSection);

        // 期待値と実際の値を抽出
        const expected = extractExpected(testSection);
        const received = extractReceived(testSection);

        failedTests.push({
          filePath,
          testName,
          errorMessage,
          codeSnippet,
          lineNumber,
          expected,
          received,
        });
      }
    }

    // 結果が見つかった場合は返す
    if (failedTests.length > 0) {
      return failedTests;
    }
  }

  // FAILで始まる行を検索し、そのセクションを抽出
  const failSections = text.split(/\n\s*FAIL\s+/);
  for (let i = 1; i < failSections.length; i++) {
    const section = 'FAIL ' + failSections[i];

    // ファイルパスらしきものを抽出
    const filePathMatch = section.match(VitestPatterns.filePath);
    if (!filePathMatch) {
      continue;
    }

    const filePath = filePathMatch[1];

    // テスト名を抽出（ファイルパスの後の部分）
    const testNameMatch = section.match(VitestPatterns.filePathAndTestName);
    const testName = testNameMatch ? testNameMatch[3].trim() : 'Unknown test';

    // エラーメッセージを抽出
    const errorMessageMatch = section.match(VitestPatterns.errorMessage);
    const errorMessage = errorMessageMatch
      ? errorMessageMatch[1].trim()
      : 'Unknown error';

    // 行番号情報を抽出
    const lineNumberMatch = section.match(VitestPatterns.lineNumber);
    const lineNumber = lineNumberMatch ? lineNumberMatch[1] : '';

    // コードスニペットと詳細情報を抽出
    const codeSnippet = extractCodeSnippet(section);
    const expected = extractExpected(section);
    const received = extractReceived(section);

    failedTests.push({
      filePath,
      testName,
      errorMessage,
      codeSnippet,
      lineNumber,
      expected,
      received,
    });
  }

  // FAILセクションから抽出できた場合は結果を返す
  if (failedTests.length > 0) {
    return failedTests;
  }

  // FAILセクションから抽出できなかった場合は、エラー行から抽出を試みる
  const errorLines = text
    .split('\n')
    .filter((line) =>
      /(?:error|fail|failed|assertion|expect|×|✗|✘)/i.test(line)
    );

  if (errorLines.length === 0) {
    return failedTests;
  }

  // テスト失敗を示す行を特定
  for (let i = 0; i < errorLines.length; i++) {
    const line = errorLines[i];

    // エラーメッセージらしき情報を抽出
    const errorMatch = line.match(VitestPatterns.errorLine);
    if (!errorMatch) {
      continue;
    }

    const errorMessage = errorMatch[1] || 'Unknown error';

    // 前後の行から情報を収集
    const prevLines = i > 0 ? errorLines.slice(Math.max(0, i - 3), i) : [];
    const nextLines =
      i < errorLines.length - 1
        ? errorLines.slice(i + 1, Math.min(errorLines.length, i + 4))
        : [];

    // テスト名を探す
    let testName = 'Unknown test';
    for (const prevLine of prevLines) {
      const testMatch = prevLine.match(VitestPatterns.testFunction);
      if (testMatch) {
        testName = testMatch[1];
        break;
      }
    }

    // ファイルパスを探す
    let filePath = 'unknown-file';
    const fullContext = [...prevLines, line, ...nextLines].join('\n');
    const fileMatch = fullContext.match(VitestPatterns.filePath);
    if (fileMatch) {
      filePath = fileMatch[1];
    }

    // 行番号情報を探す
    const lineNumberMatch = fullContext.match(VitestPatterns.lineNumberInText);
    const lineNumber = lineNumberMatch ? lineNumberMatch[1] : '';

    // 追加の詳細情報を抽出
    const expected = extractExpected(fullContext);
    const received = extractReceived(fullContext);
    const codeSnippet = extractCodeSnippet(fullContext);

    failedTests.push({
      filePath,
      testName,
      errorMessage,
      codeSnippet,
      lineNumber,
      expected,
      received,
    });

    // 余分な重複を避けるためにスキップ
    i += 2;
  }

  return failedTests;
}

----
src/services/diagnosticsService.ts
// src/services/diagnosticsService.ts
import * as vscode from 'vscode';

/**
 * 診断情報の重要度を文字列に変換
 */
export function getSeverityString(severity: vscode.DiagnosticSeverity): string {
  switch (severity) {
    case vscode.DiagnosticSeverity.Error:
      return 'Error';
    case vscode.DiagnosticSeverity.Warning:
      return 'Warning';
    case vscode.DiagnosticSeverity.Information:
      return 'Info';
    case vscode.DiagnosticSeverity.Hint:
      return 'Hint';
    default:
      return 'Unknown';
  }
}

/**
 * 現在のファイルの診断情報を取得
 */
export function getCurrentFileDiagnostics(): vscode.Diagnostic[] | null {
  const editor = vscode.window.activeTextEditor;
  if (!editor) {
    return null;
  }

  return vscode.languages.getDiagnostics(editor.document.uri);
}

/**
 * 診断情報をフィルタリング
 */
export function filterDiagnostics(
  diagnostics: vscode.Diagnostic[],
  filterOptions: {
    errorsOnly?: boolean;
  } = {}
): vscode.Diagnostic[] {
  const { errorsOnly = false } = filterOptions;

  if (errorsOnly) {
    return diagnostics.filter(
      (d) => d.severity === vscode.DiagnosticSeverity.Error
    );
  }

  return diagnostics;
}

/**
 * 診断情報のコンテキスト情報を構築
 */
export function buildDiagnosticContext(
  diagnostic: vscode.Diagnostic,
  document: vscode.TextDocument
): DiagnosticContext {
  return {
    diagnostic,
    document,
    line: diagnostic.range.start.line + 1,
    column: diagnostic.range.start.character + 1,
    lineContent: document.lineAt(diagnostic.range.start.line).text,
    severity: getSeverityString(diagnostic.severity),
    message: diagnostic.message,
  };
}

/**
 * 診断情報のコンテキスト
 */
export interface DiagnosticContext {
  diagnostic: vscode.Diagnostic;
  document: vscode.TextDocument;
  line: number;
  column: number;
  lineContent: string;
  severity: string;
  message: string;
}

/**
 * 診断情報のグループ
 * 同じファイル内で同じエラーメッセージを持つものをグループ化
 */
export interface DiagnosticGroup {
  // グループ内のコンテキスト一覧
  contexts: DiagnosticContext[];
  // 共通のファイルパス
  filePath: string;
  // 共通のエラーメッセージ
  message: string;
  // グループに固有のID
  id: string;
}

/**
 * 診断情報をグループ化する
 * 同じファイル内の同じエラーメッセージのものをまとめる
 */
export function groupDiagnostics(
  diagnostics: vscode.Diagnostic[],
  document: vscode.TextDocument
): DiagnosticGroup[] {
  // ファイル+メッセージの組み合わせでグループ化
  const groups: { [key: string]: DiagnosticGroup } = {};

  // 各診断情報を処理
  diagnostics.forEach((diagnostic) => {
    const context = buildDiagnosticContext(diagnostic, document);
    const message = diagnostic.message;
    const filePath = document.fileName;

    // グループのキーを作成（ファイルパス+メッセージ）
    const groupKey = `${filePath}:${message}`;

    if (!groups[groupKey]) {
      groups[groupKey] = {
        contexts: [],
        filePath,
        message,
        id: groupKey,
      };
    }

    groups[groupKey].contexts.push(context);
  });

  // 結果を配列に変換してソート
  return (
    Object.values(groups)
      // 行番号でソート
      .map((group) => {
        group.contexts.sort((a, b) => a.line - b.line);
        return group;
      })
      // グループをファイルパスでソート
      .sort((a, b) => a.filePath.localeCompare(b.filePath))
  );
}

----
src/services/terminalCaptureService.ts
// src/services/terminalCaptureService.ts
import * as vscode from 'vscode';

/**
 * ターミナルの出力テキストをキャプチャする
 * ターミナルのテキストを選択してクリップボードに一時的にコピーし、
 * 元のクリップボード内容を復元する
 * @returns キャプチャしたテキスト、または失敗した場合はnull
 */
export async function captureTerminalText(): Promise<string | null> {
  // 元のクリップボード内容を保存
  const originalClipboard = await vscode.env.clipboard.readText();

  try {
    // アクティブなターミナルが存在するか確認
    if (!vscode.window.activeTerminal) {
      vscode.window.showWarningMessage(
        'アクティブなターミナルが見つかりません'
      );
      return null;
    }

    // ターミナルのテキストをすべて選択
    await vscode.commands.executeCommand('workbench.action.terminal.selectAll');
    // 選択したテキストをコピー
    await vscode.commands.executeCommand(
      'workbench.action.terminal.copySelection'
    );
    // 選択を解除
    await vscode.commands.executeCommand(
      'workbench.action.terminal.clearSelection'
    );

    // クリップボードからテキストを取得
    const terminalText = await vscode.env.clipboard.readText();

    // 元のクリップボード内容を復元
    await vscode.env.clipboard.writeText(originalClipboard);

    return terminalText;
  } catch (error) {
    console.error('ターミナルテキストのキャプチャに失敗:', error);
    // 元のクリップボード内容を復元
    await vscode.env.clipboard.writeText(originalClipboard);
    return null;
  }
}

----
src/services/clipboardService.ts
// src/services/clipboardService.ts
import * as vscode from 'vscode';

/**
 * テキストをクリップボードにコピー
 */
export async function copyToClipboard(text: string): Promise<boolean> {
  try {
    await vscode.env.clipboard.writeText(text);
    return true;
  } catch (error) {
    console.error('クリップボードへのコピーに失敗しました:', error);
    return false;
  }
}

/**
 * クリップボードへのコピー成功時のメッセージを表示
 */
export function showCopySuccessMessage(
  isErrorsOnly: boolean = false,
  isGrouped: boolean = false
): void {
  let message = isErrorsOnly ? 'エラーのみ' : 'すべての診断情報';

  if (isGrouped) {
    message += '（グループ化）';
  }

  message += 'をクリップボードにコピーしました！';

  vscode.window.showInformationMessage(message);
}

/**
 * 診断情報がない場合のメッセージを表示
 */
export function showNoDiagnosticsMessage(isErrorsOnly: boolean = false): void {
  const message = isErrorsOnly
    ? '現在のファイルにエラーがありません。'
    : '現在のファイルに診断情報がありません。';

  vscode.window.showInformationMessage(message);
}

/**
 * アクティブなエディタがない場合のメッセージを表示
 */
export function showNoEditorMessage(): void {
  vscode.window.showInformationMessage(
    'アクティブなエディタが見つかりません。'
  );
}

--END--